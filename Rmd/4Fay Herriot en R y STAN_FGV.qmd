---
title: "Fay Herriot en R y STAN"
subtitle: "CEPAL - División de Estadísticas Sociales"
author: "Andrés Gutiérrez - Stalyn Guerrero"
format: html
project:
  type: website
  output-dir: docs
---

```{r setup, include=FALSE, message=FALSE, error=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE)
library(printr)
library(kableExtra)
```

# Modelo Fay-Herriot

-   El modelo FH enlaza indicadores de las áreas $\delta_d$, $d = 1, \cdots , D$, asumiendo que varían respeto a un vector de $p$ covariables, $\boldsymbol{x}_d$ , de forma constante.

-   Viene dado por

$$
\delta_d = \boldsymbol{x^T}_d\boldsymbol{\beta} + u_d ,\ \ \ \ \  d = 1, \cdots , D
$$ - ud es el término de error, o el efecto aleatorio, diferente para cada área dado por

$$
\begin{eqnarray*}
u_{d} & \stackrel{iid}{\sim} & \left(0,\sigma_{u}^{2}\right)
\end{eqnarray*}
$$

-   Sin embargo, los verdaderos valores de los indicadores $\delta_d$ no son observables. - Entonces, usamos el estimador directo $\hat{\delta}^{DIR}_d$ para $\delta_d$ , lo que conlleva un error debido al muestro.

-   $\hat{\delta}^{DIR}_d$ todavía se considera insesgado bajo el diseño muestral.

-   Podemos definir, entonces, $$
    \hat{\delta}^{DIR}_d = \delta_d + e_d, \ \ \ \ \ \ d = 1, \cdots , D 
    $$ donde $e_d$ es el error debido al muestreo, $d_{d} \stackrel{ind}{\sim} \left(0,\psi\right)$

-   Dichas varianzas $\psi_d = var_{\pi}\left(\hat{\delta}^{DIR}_d\mid\delta_d\right)$, $d = 1,\cdots,D$ se estiman con los microdatos de la encuesta.

-   Por tanto, el modelo se hace, $$
    \hat{\delta}^{DIR}_d = \boldsymbol{x^T}_d\boldsymbol{\beta} + u_d + e_d, \ \ \ \ \ \ d = 1, \cdots , D
    $$

-   El BLUP (best linear unbiased predictor) bajo el modelo FH de $\delta_d$ viene dado por

$$
    \begin{eqnarray*}
    \tilde{\delta}_{d}^{FH} & = & \boldsymbol{x_d}^{T}\tilde{\boldsymbol{\beta}}+\tilde{u}_{d}
    \end{eqnarray*}
$$

-   Si sustituimos $\tilde{u}_d = \gamma_d\left(\hat{\delta}^{DIR}_d - \boldsymbol{x_d}^{T}\tilde{\boldsymbol{\beta}} \right)$ en el BLUP bajo el modelo FH, obtenemos $$
    \begin{eqnarray*}
    \tilde{\delta}_{d}^{FH} & = & \gamma_d\hat{\delta}^{DIR}_{d}+(1-\gamma_d)\boldsymbol{x_d}^{T}\tilde{\boldsymbol{\beta}}
    \end{eqnarray*}
    $$ siendo $\gamma_d=\frac{\sigma^2_u}{\sigma^2_u + \psi_d}$.

-   Habitualmente, no sabemos el verdadero valor de $\sigma^2_u$ efectos aleatorios $u_d$.

-   Sea $\hat{\sigma}^2_u$ un estimador consistente para $\sigma^2_u$. Entonces, obtenemos el BLUP empírico (empirical BLUP, EBLUP) de $\delta_d$ ,

$$
    \begin{eqnarray*}
    \tilde{\delta}_{d}^{FH} & = & \hat{\gamma_d}\hat{\delta}^{DIR}_{d}+(1-\hat{\gamma_d})\boldsymbol{x_d}^{T}\hat{\boldsymbol{\beta}}
    \end{eqnarray*}
$$

donde $\hat{\gamma_d}=\frac{\hat{\sigma}^2_u}{\hat{\sigma}^2_u + \psi_d}$.

-   Un estimador insesgado de segundo orden del ECM (llamado el estimador Prasad-Rao) viene dado por

$$
    \begin{eqnarray*}
    mse_{PR}\left(\tilde{\delta}_{d}^{FH}\right) & = & g_{1d}\left(\hat{\sigma}_{u}^{2}\right)+g_{2d}\left(\hat{\sigma}_{u}^{2}\right)+2g_{3d}\left(\hat{\sigma}_{u}^{2}\right)
    \end{eqnarray*}
     con 
$$ con

$$
\begin{eqnarray*} g_{1d}\left(\hat{\sigma}_{u}^{2}\right) & = & \gamma_{d}\psi_{d}\\
g_{2d}\left(\hat{\sigma}_{u}^{2}\right) & = & \left(1-\gamma_{d}\right)^{2}\boldsymbol{x}^{T}\left(\sum_{d=1}^{D}\left(\sigma_{u}^{2}+\psi_{d}\right)\boldsymbol{x}_{d}\boldsymbol{x}_{d}^{T}\right)^{-1}\boldsymbol{x}_{d},\\
g_{3d}\left(\hat{\sigma}_{u}^{2}\right) & = & \left(1-\gamma_{d}\right)^{2}\left(\sigma_{u}^{2}+\psi_{d}\right)^{-1}\overline{var}\left(\hat{\sigma}_{u}^{2}\right),
\end{eqnarray*} 
$$

donde $$
\begin{eqnarray*}
\overline{var}\left(\hat{\sigma}_{u}^{2}\right) & = & \mathit{I}^{-1 }\left(\sigma_{u}^{2}\right)=2\left\{ \sum_{d=1}^{D}\left(\sigma_{u}^{2}+\psi_{d}\right)^{-2}\right\} ^{-1}
\end{eqnarray*}
$$ para un estimador REML y $\mathit{I}$ es la información Fisher

## Transformaciones FGV 

Uno de los insumos más importantes en el modelo de áreas es la 
varianza del estimador directo, a nivel de dominio, la cual no puede calcularse de ningún modo. En correspondencia, este valor debe estimarse desde los datos recolectados en cada dominio. Sin embargo, 
en dominios en las que se cuenta con un tamaño de muestra muy pequeño, estas estimaciones no tendrán un buen comportamiento. Por ende, es muy útil utilizar un modelo de **suavizamiento** de las varianzas para 
eliminar el ruido y la volatilidad de estas estimaciones y extraer la verdadera señal del proceso

Hidiroglou (2019) afirma que $E_{mp}\left(\hat{\theta}^{dir}_d\right)=\boldsymbol{x}_{d}\boldsymbol{\beta}$ y $V_{mp}\left(\hat{\theta}^{dir}_d\right)=\sigma_{u}^2+\tilde{\psi}^2_{d}$, en donde el subíndice  $mp$ hace referencia a la inferencia doble que se debe tener en cuenta en este tipo de ajustes y define la medida de probabilidad conjunta entre el modelo y el diseño de muestreo.  

-   $m$ hace referencia a la medida de probabilidad inducida por el modelamiento y la inclusión de las covariables auxiliares ($\boldsymbol{x}_{d}$).

-   $p$ hacer referencia a la medida de probabilidad inducida por el diseño de muestreo complejo que 
induce las estimaciones directas. 

Además, $\tilde{\psi}^2_{d} = E_m\left(\tilde{\psi}^2_{d}\right)$ es la varianza suavizada del estimador directo $\hat{\theta}^{dir}_d$.  



# Estimación de Fay Herriot normal.

-   El estimador directo no es el único insumo del modelo de áreas de Fay-Herriot; también lo es su varianza. El estimador puntual da un indicio de la localización del parámetro, y su varianza presenta el nivel de certeza o confianza sobre esta localización.

-   Al tratar con cifras provenientes de procesamientos con encuestas de hogares, es indispensable siempre tener en cuenta que el sustento inferencial recae en la estrategia de muestreo, definida como la dupla compuesta por el diseño de muestreo y el estimador escogido.

## Datos de la encuesta

```{r}
library(tidyverse)
library(magrittr)
source("0Funciones/0Source_FH.R")

encuesta <- readRDS("../Data/encuestaURY19N_Montevideo.rds") %>% 
  mutate(wkx = fep, 
         pobreza = ifelse(ingcorte < lp, 1 , 0))

```

-   *depto*: Corresponde al código asignado a la segunda división administrativa del país.

-   *segm*: Corresponde al código asignado a la cuarta división administrativa del país.

-   *lp* y *li* lineas de pobreza y pobreza extrema definidas por CEPAL. 

-   Factor de expansión por persona (*fep*)


```{r, echo=FALSE}
kable(encuesta %>% head(10),
      format = "html", digits =  4,
      caption = "Encuesta") %>% 
    kable_classic()
```

Definir el diseño muestral

```{r}
library(survey)
library(srvyr)
options(survey.lonely.psu = "adjust")

diseno <-
  as_survey_design(
    ids = upm,
    weights = wkx,
    strata = estrato,
    nest = TRUE,
    .data = encuesta
  )

```

Para la estimación directa de la proporción se emplea la función `direct.supr`, dando como resultado.

```{r}
directoSegm <- direct.supr(design.base = diseno,
                             variable = pobreza, 
                             group = segm,
                             upm = upm,
                             estrato = estrato)

directoSegm %>%
  group_by(Flag) %>%
  summarise(n = n()) %>% 
  arrange(n)
```



```{r}
##############################################################
# Transformación Arcoseno, calculo del DEFF y varianza zd    #
##############################################################

base_sae <- directoSegm %>% filter(Flag != "Excluir") %>%
  transmute(
    segm = segm,
    nd = n,
    n_effec = n.eff,
    pobreza = p,
    pobreza_T = asin(sqrt(pobreza)),
    vardir = ee ^ 2,
    cv = CV,
    var_zd = 1 / (4 * n_effec),
    deff_segm = deff
  )

base_sae1 <- base_sae [base_sae$vardir>0,]
```









```{r}

################################################################################
#-------- FGV para las varianzas directas de las comunas seleccionadas --------#
################################################################################

# Vitacura con varianza 0 #

baseFGV <-  base_sae1 %>% 
  select(segm, pobreza, nd, vardir) %>%
  mutate(ln_sigma2 = log(vardir))

###---------------------------- Análisis gráfico ----------------------------###

theme_set(theme_bw())

# pobreza vs Ln_sigma2 #

p1 <- ggplot(baseFGV, aes(x = pobreza, y = ln_sigma2)) +
  geom_point() +
  geom_smooth(method = "loess") +
  xlab("pobreza")

# Tamaño de muestra vs Ln_sigma2 #

p2 <- ggplot(baseFGV, aes(x = nd, y = ln_sigma2)) + 
  geom_point() +
  geom_smooth(method = "loess") + 
  xlab("Tamaño de muestra")

# Número de pobres vs Ln_sigma2 #

p3 <- ggplot(baseFGV, 
             aes(x = pobreza * nd, y = ln_sigma2)) + 
  geom_point() +
  geom_smooth(method = "loess") + 
  xlab("Número de pobres")

# Raiz_pobreza vs Ln_sigma2 #

p4 <- ggplot(baseFGV, 
             aes(x = sqrt(pobreza), y = ln_sigma2)) + 
  geom_point() +
  geom_smooth(method = "loess") + 
  xlab("Raiz cuadrada de pobreza")

###-------------------------- Gráfico con patchwork -------------------------###
library(patchwork)
(p1 | p2) / (p3 | p4)

###------------------------- Modelo para la varianza ------------------------###

FGV1 <- lm(ln_sigma2 ~ 1 + pobreza + 
             nd + I(nd ^ 2) + I(pobreza * nd) +
             I(sqrt(pobreza)) + I(sqrt(nd)) + 
             I(sqrt(pobreza * nd)),
     data = baseFGV)
summary(FGV1)

###--- Ponderador FGV ---###

delta.hat = sum(baseFGV$vardir) / 
  sum(exp(fitted.values(FGV1)))
delta.hat
###--- Varianza suavizada ---###

hat.sigma <- data.frame(segm = baseFGV$segm,
                        hat_var = delta.hat * exp(fitted.values(FGV1)))

baseFGV$ln_sigma2_pred <- hat.sigma$hat_var

###-------------------- Validación del modelo para la FGV -------------------###

par(mfrow = c(2, 2))
plot(FGV1)

###----- Comparación entre varianza estimada con pronosticada por la FGV ----###

ggplot(baseFGV, 
       aes(x = ln_sigma2, y = ln_sigma2_pred)) + 
  geom_point() +
  geom_smooth(method = "loess")

###---------------------------- Varianza suavizada --------------------------###

prediccion_ln_0 = predict(FGV1, newdata = base_sae %>%
                            filter(!is.na(pobreza))) 
base_sae <- base_sae %>% 
  left_join(hat.sigma, by = "segm")

base_sae$hat_var[base_sae$vardir == 0 & !is.na(base_sae$vardir)] <-
  delta.hat * exp(prediccion_ln_0)

###--------------------------------------------------------------------------###
###--- Consolidación de la base para modelo SAE con varianzas suavizadas, ---###
###-------------- Efecto de diseño y tamaño de muestra efectivo -------------###
###--------------------------------------------------------------------------###

base_FH <- base_sae %>%
  mutate(
    deff_segm = ifelse(is.nan(deff_segm), 1,
                         deff_segm),
    deff_FGV = ifelse(
      vardir == 0 ,
      1,
      hat_var / (vardir / deff_segm)
    ),
    # Criterio MDS para regularizar el DeffFGV
    deff_FGV = ifelse(deff_FGV < 1, 1, deff_FGV),
    n_eff_FGV = nd / deff_FGV
  )

saveRDS(object = base_FH, "../Data/base_FH_2019.rds")

###---------------------------- Análisis gráfico ----------------------------###

theme_set(theme_bw())
#---  Comparación de la varianza directa respecto a la obtenida por la FGV  ---#

ggplot(base_FH %>% filter(!is.na(hat_var)) %>% 
         arrange(nd), aes(x = hat_var, y = vardir)) + 
  geom_point() + 
  geom_smooth(method = "lm", col = 2) + 
  labs(x = "FGV", y = "VarDirEst") +
  ylab("Varianza del Estimador Directo")


```

